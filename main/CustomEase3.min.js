var CustomEase = (function() {
  function createEasing(points) {
    function ease(t) {
      var sectionStep = 1 / (points.length - 1);
      var segmentIndex = Math.min(Math.floor(t / sectionStep), points.length - 2);
      var tWithinSegment = (t - segmentIndex * sectionStep) / sectionStep;

      var p0 = points[segmentIndex];
      var p1 = points[segmentIndex + 1];

      var t2 = tWithinSegment * tWithinSegment;
      var t3 = t2 * tWithinSegment;

      var a = 1 - tWithinSegment;
      var b = tWithinSegment;

      var interpolatedValue =
        a * (a * p0 + b * p0.cpOut) +
        b * (a * p1.cpIn + b * p1);

      return interpolatedValue;
    }

    return ease;
  }

  return {
    create: function(points) {
      return createEasing(points);
    }
  };
})();

// Example usage:
var myCustomEasing = CustomEase.create([
  { s: 0, cpIn: 0.1, cpOut: 0.1, e: 1 },
  { s: 0, cpIn: 0.1, cpOut: 0.9, e: 1 },
  { s: 0, cpIn: 0.5, cpOut: 0.5, e: 1 }
]);

// You can now use myCustomEasing as your custom easing function without GSAP.
// Get a reference to the element you want to animate
var elementToAnimate = document.getElementById('myElement');

// Define the animation duration in milliseconds
var animationDuration = 1000; // 1 second

// Store the start time of the animation
var startTime = null;

function animate() {
  if (!startTime) {
    startTime = performance.now();
  }

  // Calculate the progress of the animation (a value between 0 and 1)
  var currentTime = performance.now();
  var progress = Math.min((currentTime - startTime) / animationDuration, 1);

  // Apply the custom easing function to calculate the new position
  var easingValue = myCustomEasing(progress);

  // Update the element's position based on the easing value
  elementToAnimate.style.transform = 'translateX(' + (easingValue * 100) + 'px)';

  if (progress < 1) {
    // Continue the animation
    requestAnimationFrame(animate);
  }
}

// Start the animation
requestAnimationFrame(animate);
